/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package edu.uw.complexkotlin

// write a lambda using map and fold to solve "FIZZBUZZ" for the first fifteen numbers (0..15).
// use map() to return a list with "", "FIZZ" (for 3s) or "BUZZ" (for 5s).
// use fold() to compress the array of strings down into a single string.
// the final string should look like FIZZBUZZFIZZFIZZBUZZFIZZFIZZBUZZ for 0..15.
// store this lambda into 'fizzbuzz' so that the tests can call it

// val fizzbuzz : (IntRange) -> String = { _ -> "" }
// (IntRange) -> String It specifies the type of fizzbuzz. 
// The type is a function type that takes an IntRange as its parameter and returns a String
// { _ -> "" } means the lambda takes one parameter denoted by "_" but doesn't really use it, and it returns an empty string

val fizzbuzz: (IntRange) -> String = { range ->
    range.map { num ->
        when {
            num % 15 == 0 -> "FIZZBUZZ"
            num % 3 == 0 -> "FIZZ"
            num % 5 == 0 -> "BUZZ"
            // num % 7 == 0 -> "DOH"
            else -> ""
        }
    }.fold("") { acc, str -> acc + str }
}
//  The system knows that number is the single number in the range because the map function iterates over each element in the range one by one, 
// and the lambda parameter n represents each element in turn.


// Example usage
/*
if (fizzbuzz(0..1) == "")
    println("Success!")
if (fizzbuzz(0..3) == "FIZZ")
    println("Success!")
if (fizzbuzz(0..5) == "BUZZ")
    println("Success!")
*/

// This is a utility function for your use as you choose, and as an
// example of an extension method
fun Int.times(block: () -> Unit): Unit {
    for (it in 1..this) {
        block()
    }
}

// Use this function
fun process(message: String, block: (String) -> String): String {
    return ">>> ${message}: {" + block(message) + "}"
}


// Create r1 as a lambda that calls process() with message "FOO"
// and a block that returns "BAR"
val r1 = { process("FOO") { "BAR" } }

// block: (String) -> String specifies that block is a lambda expression that
// takes a String as input and returns a String as output.


// Create r2 as a lambda that calls process() with message "FOO"
// and a block that upper-cases r2_message, and repeats it three
// times with no spaces: "WOOGAWOOGAWOOGA"
val r2_message = "wooga"
val r2 = { process("FOO") { r2_message.toUpperCase().repeat(3) } }



// write an enum-based state machine between talking and thinking
enum class Philosopher {
// shift from one state to the other when told to do so via the method call signal
// When THINKING, a Philosopher will return "Deep thoughts..."
    THINKING {
        override fun signal() = TALKING
        override fun toString() = "Deep thoughts...."
        },
          
    // When TALKING, a Philosopher will return "Allow me to suggest an idea...".
    TALKING {
    override fun signal() = THINKING
    override fun toString() = "Allow me to suggest an idea..."
    };
     
    abstract fun signal(): Philosopher
 }
// EXTRA CREDIT
// Answer:
// 1. Seneca the Younger, often referred to simply as Seneca, was a prominent Roman philosopher, statesman, and playwright. He was born around 4 BC and died in AD 65. Seneca is commonly associated with the school of philosophy known as Stoicism.
// 2. Stoicism is a Hellenistic philosophical school that emphasizes rationality, virtue, and self-control as the path to a tranquil and fulfilling life.



// create an class "Command" that can be used as a function 
// (provide an "invoke()" function)
// that takes a single parameter ("message" of type String)
// primary constructor should take a String argument ("prompt")
// when invoked, the Command object should return a String c
// ontaining the prompt and then the message.
// Example: Command(": ")("Hello!") should print ": Hello!"
class Command(val prompt: String) {
    operator fun invoke(message: String): String {
    return "${prompt}${message}"
    }
    }
    
